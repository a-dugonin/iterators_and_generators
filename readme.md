# Задача 5. Обработка логов
### Контекст 

Вы работаете в большой компании, которая обслуживает сложную систему торговли. Каждый день генерируется огромное количество лог-файлов, содержащих информацию о торговых операциях. Вам поставлена задача разработать программу, которая будет автоматически анализировать эти лог-файлы и находить строки с сообщениями об ошибках (ERROR). Это поможет вам быстро отслеживать проблемы в торговой системе и эффективно на них реагировать.
### Задача 

Напишите программу, которая считывает строки из файла и выводит строки, содержащие слово ERROR, в новый файл. 

**Требования**

* Используйте модуль os для работы с файлами и путями.
* Учтите, что файл может быть очень большим по объёму, поэтому не загружайте его в память целиком.
* Создайте функцию-генератор error_log_generator, которая будет получать на вход путь до файла с логами и возвращать строки из этого файла, которые содержат слово ERROR (одно обращение к генератору должно возвращать одну строку из файла).

**Советы**

* Цикл for по файлу будет считывать в память ровно по одной строке из файла за итерацию.
* Генератор должен возвращать только строки со словом ERROR. Другие строки, которые будут считываться из файла, нужно будет игнорировать (применять yield только к правильным строкам).
* Для наглядного примера вы можете сгенерировать очень большой текстовый файл (для этого надо запустить код из файла text_generator.py) и попробовать загрузить его в память при помощи метода read(), применённого к этому файлу. 

Учтите, что генерация файла такого размера может занять несколько десятков минут!


### Что оценивается в практической работе

* Практическая работа сдана через GitLab.
* Структура папок и файлов репозитория соответствует репозиторию python_basic.
* Все задачи выполнены в соответствующих папках и файлах main.py.
* Описания коммитов осмыслены и понятны: 111, done, «я сделалъ» — неверно, added m15 homework, 14.3 fix: variables naming — верно.
* Использованы именованные индексы, не просто i (подробнее об этом в видео 7.2).
* Использованы правильные числа, без дополнительных действий со стороны пользователя, без +1 (подробнее об этом в видео 7.4).
* Правильно оформлен input, без пустого приветствия для ввода (подробнее об этом в видео 2.3).
* Переменные и функции имеют значащие имена, не только a, b, c, d (подробнее об этом в видео 2.3).
* Присутствуют пробелы после запятых и при бинарных операциях.
* Отсутствуют пробелы после имён функций и перед скобками: print (),input () — неверно, print() — верно.
* Правильно оформлены блоки if-elif-else, циклы и функции, отступы одинаковы во всех блоках одного уровня.
* Все входные и выходные файлы называются так, как указано в заданиях.
* Работа с файлами осуществляется с помощью контекстного менеджера with.
* Для обработки исключений используются блоки try-except.
* Модели реализованы в стиле ООП, основной функционал описан в методах классов и в отдельных функциях.
* При написании классов соблюдаются основные принципы ООП: инкапсуляция, наследование и полиморфизм.
* Для получения и установки значений у приватных атрибутов используются сеттеры и геттеры.
* Для создания нового класса на основе уже существующего используется наследование.
* Если классы вынесены в отдельный модуль, то импортируются определённые классы (запись вида from garden import * считается плохим тоном).
* Классы и методы/функции имеют прописанную документацию (хотя бы минимальную).
* Есть аннотация типов для методов/функций и их аргументов (кроме args и kwargs). Если функция/метод ничего не возвращает, то используется None.